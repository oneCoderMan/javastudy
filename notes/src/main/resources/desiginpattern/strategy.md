# 1. 策略模式简介
策略模式是一种行为设计模式，它能让你定义一系列算法，
并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。

特点：
名为上下文的原始类必须包含一个成员变量来存储对于每种策略的引用。 上下文并不执行任务， 而是将工作委派给已连接的策略对象。

上下文不负责选择符合任务需要的算法——客户端会将所需策略传递给上下文。 实际上， 上下文并不十分了解策略， 它会通过同样的通用接口与所有策略进行交互， 
而该接口只需暴露一个方法来触发所选策略中封装的算法即可。

优势：上下文可独立于具体策略。 
这样你就可在不修改上下文代码或其他策略的情况下添加新算法或修改已有算法了。

# 2. 一个线路规划的问题
功能：希望输入地址后就能在地图上看到前往目的地的最快路线。

路线分类：公路路线，步行路线，公共交通路线，地铁路线等等

使用策略模式后，对应的UML类图如下：
<div align="center">
	<img src="https://github.com/oneCoderMan/javastudy/blob/8460a32d6d5149cc10f48111a111f5f234a17868/notes/src/main/resources/desiginpattern/pics/st1.png" alt="Editor" width="700">
</div>

每个路线规划算法都可被抽取到只有一个`buildRoute`生成路线方法的独立类中。 
该方法接收起点和终点作为参数， 并返回路线中途点的集合。

# 3. 策略模式通用结构
UML类图如下：
<div align="center">
	<img src="https://github.com/oneCoderMan/javastudy/blob/8460a32d6d5149cc10f48111a111f5f234a17868/notes/src/main/resources/desiginpattern/pics/st2.png" alt="Editor" width="700">
</div>

## 使用场景
* 当你想使用对象中各种不同的算法变体，并希望能在**运行时切换**算法时，可使用策略模式。
* 当你有许多仅在执行某些行为时略有不同的相似类时，可使用策略模式
* 如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。

## 实现方式
1. 从上下文类中找出修改频率较高的算法 （也可能是用于在运行时选择某个算法变体的复杂条件运算符）。
2. 声明该算法所有变体的通用策略接口。
3. 将算法逐一抽取到各自的类中， 它们都必须实现策略接口。
4. 在上下文类中添加一个成员变量用于保存对于策略对象的引用。
5. 在上下文类提供设置器以修改该成员变量。 上下文仅可通过策略接口同策略对象进行交互， 如有需要还可定义一个接口来让策略访问其数据。
6. 客户端必须将上下文类与相应策略进行关联， 使上下文可以预期的方式完成其主要工作。




# REF
[深入理解策略模式](https://refactoring.guru/design-patterns/strategy)
