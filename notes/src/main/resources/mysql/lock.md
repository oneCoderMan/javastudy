# 1. 锁的解决问题
作用：数据库锁设计的初衷是处理并发问题。
作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。
而锁就是用来实现这些访问规则的重要数据结构

分类（加锁范围）：全局锁、表级锁和行锁

# 2. 全局锁
对整个数据库实例加锁

命令：`Flush tables with read lock`

作用：当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

使用场景： 做全库逻辑备份，也就是把整库每个表都select出来存成文本



# 3. 表级锁
分类： 一种是表锁，一种是元数据锁（meta data lock，MDL)

## lock tables
表锁的语法是 `lock tables … read/write`
> lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。
> <br>举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。
> 连写t1都不允许，自然也不能访问其他表。

对于InnoDB这种支持行锁的引擎，一般不使用`lock tables`命令来控制并发，毕竟锁住整个表的影响面还是太大。

## MDL
MDL不需要显式使用，在访问一个表的时候会被自动加上

作用：MDL的作用是保证读写的正确性。
你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，
那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

影响：如果有查询很频繁，修改表结构的时候会被MDL读锁给阻塞，

如何安全的给查询请求的表加字段：
* 要解决长事务，事务不提交，就会一直占着MDL锁，你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务
* 在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃，之后开发人员或者DBA再通过重试命令重复这个过程


# 4. 行锁
实现地方：MySQL的行锁是在引擎层由各个引擎自己实现的
> 并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁

两阶段锁协议：在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，
而是要等到事务结束时才释放


# REF
[讲全局锁和表锁](https://funnylog.gitee.io/mysql45/06%E8%AE%B2%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%EF%BC%9A%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D.html)
