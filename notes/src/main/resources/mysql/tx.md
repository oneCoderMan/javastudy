# 1. 事务概念
四个特性：ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

实现地方：在MySQL中，事务支持是在引擎层实现的

# 2. 隔离性
## 解决问题
多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题

## 隔离级别

|           隔离级别           |            解释            |
|:------------------------:|:------------------------:| 
| 读未提交（read uncommitted）   | 一个事务还没提交时，它做的变更就能被别的事务看到 |
|           读提交（read committed）            |             一个事务提交之后，它做的变更才会被其他事务看到             |
|           可重复读（repeatable read）            |           一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的           |
|           串行化（serializable ）            |           同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行            |

## 一个例子

假设数据表T中只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。

<div align="center">
	<img src="https://github.com/oneCoderMan/javastudy/blob/bbcd09e6b497af1d93425165933212b0d0e2ccb5/notes/src/main/resources/mysql/pics/tx2.png" alt="Editor" width="500">
</div>

看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。

* 若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。
* 若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。
* 若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
* 若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。

## 事务的实现
在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，
这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，
没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。


[了解更多](https://funnylog.gitee.io/mysql45/03%E8%AE%B2%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81.html)

# 3. 事务的MVCC实现
如果是可重复读隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样。也就是说，
一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。

行锁的时候又提到，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进入了等待状态，
那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？


今天为了说明查询和更新的区别，把read view拆开。你可以结合这两篇文章的说明来更深一步地理解MVCC，
[事务MVCC实现](https://funnylog.gitee.io/mysql45/08%E8%AE%B2%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84.html)

## 快照的实现
在可重复读隔离级别下，事务在启动的时候就“拍了个快照”，这个快照是基于整库的。

InnoDB里面每个事务有一个唯一的事务ID，叫作`transaction id`。
它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的

而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，
并且把`transaction id`赋值给这个数据版本的事务ID，记为`row trx_id`。
同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

也就是说，数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的`row trx_id`。

下图就是一个记录被多个事务连续更新后的状态，三个虚线箭头，就是**undo log**

<div align="center">
	<img src="https://github.com/oneCoderMan/javastudy/blob/753450b66c435b953cb0797095a1e06ec5efe7dd/notes/src/main/resources/mysql/pics/tx3.png" alt="Editor" width="500">
</div>

>而V1、V2、V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。

## REF
