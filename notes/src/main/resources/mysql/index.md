# 1. 索引介绍
索引的出现其实就是为了提高数据查询的效率，索引是在存储引擎层实现的



# 2. InnoDB的索引模型
在InnoDB中，表都是根据主键顺序以索引的形式存放的(索引组织表)

InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。

我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。建表语句如下：
```mysql
create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k)) engine=InnoDB;
```
有5个数据：分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)
那么这两个索引组织的数如下：
<div align="center">
	<img src="https://github.com/oneCoderMan/javastudy/blob/844e9538e0c17bdee8c1b0ef73b888ae331f82f4/notes/src/main/resources/mysql/pics/index.png" alt="Editor" width="500">
</div>

| 索引分类 | 叶子节点形态 |          别名           |
|:----:| :----: |:---------------------:| 
| 主键索引  | 叶子节点存的是整行数据 | 聚簇索引（clustered index） | 
| 非主键索引  | 叶子节点内容是主键的值 | 二级索引（secondary index） | 

基于主键索引和普通索引的查询有什么区别？
* 如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；
* 如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。

>基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。


# 3. 索引优化（覆盖索引）
一个例子如下：
```mysql
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

两颗索引树如下：


问题：执行`select * from T where k between 3 and 5`，需要执行几次树的搜索操作，会扫描多少行？

这个SQL执行流程如下：
1. 在k索引树上找到k=3的记录，取得 ID = 300；
2. 再到ID索引树查到ID=300对应的R3；
3. 在k索引树取下一个值k=5，取得ID=500；
4. 再回到ID索引树查到ID=500对应的R4；
5. 在k索引树取下一个值k=6，不满足条件，循环结束。

这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。

优化思路：由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？

具体实践：如果执行的语句是`select ID from T where k between 3 and 5`
这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为**覆盖索引**。

>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。


# 4. 索引查询性能分析（普通索引vs唯一索引）
假设字段 k 上的值都不重复。
## 查询过程
查询的语句是 `select id from T where k=5`。这个查询语句在索引树上查找的过程，
先是通过B+树从树根开始，按层搜索到叶子节点，
也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。


* 对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。
* 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。

性能差距会有多少呢？答案是，微乎其微。

>因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，
> 要多做的那一次“查找和判断下一条记录”的操作，
> 就只需要一次指针寻找和一次计算。

## 更新过程
结论：唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。

如果要在这张表中插入一个新记录(4,400)的话，InnoDB的处理流程是怎样的。

1. 这个记录要更新的目标页在内存中
   * 对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束；
   * 对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。

2. 这个记录要更新的目标页不在内存中
   * 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；
   * 对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。

将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，
所以对更新性能的提升是会很明显的。

## 实践
1. `change buffer`只限于用在普通索引的场景下，而不适用于唯一索引。
2. 这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。 所以，建议你尽量选择**普通索引**。
3. 如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭`change buffer`


# REF
[普通索引vs唯一索引](https://funnylog.gitee.io/mysql45/09%E8%AE%B2%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9.html)
